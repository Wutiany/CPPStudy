# 从零开始构建 gin 项目

## 1. 配置文件

### 1.1 不暴露的配置文件

* yaml（json） 配置文件（其中配置按照每个不同模块进行划分）

* 配置文件剥离
  * 主 config 文件，作为对外暴漏的结构体，其中封装了其他的配置文件作为**字段**
  * 其他 config 文件，将不同服务的配置文件进行抽象化，同时设置 tag，作为配置托管来进行监控和加载配置文件

### 1.2 对外暴露的配置文件

* global 配置文件：直接在配置文件中进行实例化，使外部进行访问
  * 配置文件结构体封装了两个
    * Viper 托管的字段
    * Config 字段，用来访问配置

### 1.3 对外初始化配置的 func

**用来返回一个 viper 实例**

* 通过获取 `config.yaml` 来初始化配置
* 同时监控配置文件的配置变化，进行配置热重载
* 在配置修改时，**文件代码不需要变动**，只需修改配置内容（config 文件的字段）

### 1.4 日志配置文件文件

**使用 zap 作为日志库，结合 lumberjack 实现日志切割归档**

* `zap` 只是日志库，需要一个持久化的 `iowriter`
  * 通过 zapcore 来扩展日志库的日期编码格式，日志等级编码格式等
* `lumberjack` 可以实现日志文件的配置，文件名，最大尺寸等，可以用来操作日志文件
  * `lumberjack` 实现了一个 `Logger` 结构体，该结构体实现了 `iowriter` 接口的方法，可以作为接口传入，同时结构体本身会对日志文件进行控制
* 书写单独的 log 结构体，同时在 config 结构体中增加 log 结构体的字段，然后在启动文件夹下，将日志初始化函数编写出来，通过 viper 获取的配置文件进行初始化

### 1.5 数据库配置文件

**使用 gorm 作为操作数据库的库**

* 数据库的配置文件
* 全局配置文件（gorm.DB）

## 2. 日志文件

### 2.1 配置文件

* 选择使用的日志库（zap），以及管理日志文件的库（lumberjack）

* 在`config.yaml` 中增加日志的配置文件
* 全局日志文件中增加 `zap` 的 `Logger`

### 2.2 日志库初始化

* 创建初始化日志库的函数

  * 检查存储日志的路径
  * **设置日志级别**（只要是日志，这个就是必须的）

  * 初始化 `zap`
    * 初始化 `lumberjack` 的 `logger`（LogWriter）
    * 设置 `zap` 的扩展，编码格式，日志级别，通过自定义的 `Writer` 去初始化 `zap`
  * 将初始化的 `zap logger` 赋值给全局配置文件中的 `Logger`

## 3. GORM

### 3.1 配置文件

* `config` 中的数据库配置结构体，用来初始化的时候获取配置信息
* `global` 中的 `DB` 配置，用来获取初始化后的 `DB`，来进行后续操作

### 3.2 数据库初始化

*  重写 `logger`，使用自定义的 `logger`
  * 通过配置文件初始化 `lumberjack` 的 `logger`，进行日志文件管理（返回的时 Writer）
  * 获取 `gorm` 的 `logger`，将已经定义的 `logger`，初始化 `gorm` 的 `logger`（还需要使用 logger.Config 来设置 gorm 的日志设置），使用已经创建的 `writer`，还需要设置日志等级
* 初始化 DB，使用简单工厂，根据配置文件的 `driver` 类型进行初始化
* 初始化 `mysql`：
  * 通过 `mysql.Config` 初始化
  * 同时通过 `gorm.DB` 的方法（.DB()）获取 `sql.DB` 来设置连接池等操作
  * 初始化表，这个需要创建 **表单** 结构体
* 创建 `models` 的表单结构体，用来初始化和操作数据库（与 go-zero 差不多，产生 models）
  * 这个结构体一方面可以用来初始化数据库，一方面可以用来获取查询结果或者进行插入更新等，就相当于表的记录
* 需要创建结构体

## 4. 静态资源以及优雅重启服务器

**需要将路由以及服务器启动抽象出来，放到 bootstrap 文件夹下**

* 静态资源通过设置路由的函数进行加载（路由对应的静态资源），如果要加载全局的静态资源，可以在服务器初始化（服务器启动）的函数中进行加载
* 优雅重启路由器
  * 需要配合 `http.Server`，将原本的 `Engine` 作为 `handler` 给 `http.Server`
  * 创建一个接受中断信号的通道，捕获终端信号
  * 获取信号后，创建超时上下文，通过 `http.Server` 自带的 `Shutdown` 来进行关闭服务器（超时上下文作为传入参数）

