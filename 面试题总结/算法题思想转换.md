# 算法题思想转换

## 动态规划转换

## 辅助数（数组）转换

### [剑指 Offer 63. 股票的最大利润](https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/)

>  假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？
>

* **问题转换：**股票收益最大 == 当前股票的价钱减去之前最小的价钱  --->  转换成：遍历数组每个元素，找当前数组前面元素的最小值（两个嵌套循环遍历）
* **优化：**找前面元素的最小值可以转换成使用**辅助数值**（minPrice）来在外层遍历数组每个元素的时候去**记住最小值**
* **优化后的优点：**节省时间开销   O(n^2) --> O(n)
* **算法具体规划：**

``` c++
// 为 minPrice 获取首个元素，前提数组长度不能为 0
len(prices) != 0;
minPrice = prices[0];   // 初始化辅助数值
maxProfit = 0;   // 初始化利润暂存
for (prices[1] ... prices[n]) {
    // 先获取利润
    // 比较后更新最大利润
    // 比较后更新最小值
}
```

## 广度优先遍历

### [994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/)

> 在给定的 `m x n` 网格 `grid` 中，每个单元格可以有以下三个值之一：
>
> - 值 `0` 代表空单元格；
> - 值 `1` 代表新鲜橘子；
> - 值 `2` 代表腐烂的橘子。
>
> 每分钟，腐烂的橘子 **周围 4 个方向上相邻** 的新鲜橘子都会腐烂。
>
> 返回 *直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 `-1`* 。

* **问题转换：**向四周扩散 == 一个节点连接四个节点 == 树型，全部扩散完 == 广度优先搜索（层序遍历）-->  转换成：对所有的烂橘子的点进行层序遍历
* **优化：**多源层序遍历（同时对所有烂橘子进行层序遍历）
* **优化后的优点：**节省时间开销  O(nm)
* **其他转换：**使用**辅助数组（通常用来记录结果）**记录步数
* **算法具体规划：**

```c++
// 初始化辅助数组
queue<int, int> idx; // 记录索引的队列
vector<vector<int>> time(n, vector<int>(m, -1)); // 记录每个橘子腐烂时间的数组
vector<int> dir_x = {0, 1, 0, -1};  // 方向数组
vector<int> dir_y = {-1, 0, 1, 0};
cnt = 0;  // 好橘子的个数
ret = 0;  // 最后的时间结果

for for;  // 遍历橘子数组，用来找橘子的个数以及初始化时间数组（本身就是腐烂橘子初始化为 0），同时放入队列用来进行广度优先遍历
while (!idx.empty()) {
    // 取出队头的元素(烂橘子的索引)
    pair<int, int> front = idx.front(); idx.pop();
    for // 对当前烂橘子的四周进行扩散，使用方向数组
    {
        // 获取位置索引
        if; // 判断当前位置是否合法，同时在橘子数组中存在橘子，以及时间数组中不为-1（-1表示这个地方什么都没有）
        // 更新新位置的时间
        // 将位置放入队列进行下一层的遍历
        if; // 本身是坏橘子不用管，只需要考虑好橘子的情况，更新 ret 和 cnt
    }
}
// 需要判断一下还有没有好橘子
return cnt ? 0 : ret;
```

