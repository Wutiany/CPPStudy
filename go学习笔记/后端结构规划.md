# 后端结构规划

# 1 结构体

## 1.1 request 结构体

* 请求需要绑定的结构体，要抽出来，因为不同 router 请求的结构体会**不同**，**传给后端的数据**不同
* 作为**形参**传给数据库**查询逻辑**，
* 请求结构体可以做**验证（Validation）**（增加 binding tag ）

## 1.2 response 结构体

* 响应结构体大致可以使用一个公用的
  * code
  * result
  * message
* data：可以用来存放返回的结果，所以大部分请求不需要专门设置请求

## 1.3 model 结构体

* model 结构体用来操作**数据库**
  * 一般用来 `GORM` 的 `tag` 定义
  * 这个结构体通常由**查询逻辑**中来使用，同时作为结果返回给**路由的 handler**（或者重新定义一个返回的结构体？）

## 1.4 Options 结构体

* 用来接收**配置参数**

## 1.5 路由结构体

**路由结构体**用过调用各**服务接口**来获取数据以及服务操作

* 日志接口：写日志
* jwt 接口：获取服务器配置好的 jwt 服务（获取 token）
* logic 接口：实际的数据库调用操作放在这里，同时返回数据库 model 数据给 handler
* 等

# 2 结构拆分

## 2.1 路由逻辑

**路由 handler --> 实际处理逻辑接口 || rpc 查询函数 || 其他处理函数 --> 初始这些调用获取的结果**

### 2.1.1 路由 handler

**强解耦，所以 路由 handler 不进行实际操作，实际操作拆分到其他调用中， handler 只负责组织数据以及一些逻辑操作**

* 数据库操作做成**数据库调用**，不由 handler 去操作数据库
* rpc 同样，只负责调用 rpc 的 func，来处理**接收的结果**
* 只进行**数据**的**中转和处理**
* 返回 `response`

### 2.1.2 路由 logic

**实际调用数据库接口的操作放在这里面**

* 主要操作的逻辑，包括对获取的数据进行处理，都放在这里面

## 2.2 Engine 依赖

**提供访问各个依赖的接口，不直接操作依赖的结构体**

* 依赖注入，每个依赖创建一个 **newDepend** 的方法，用来初始化依赖的**接口**，**不直接访问**依赖的结构体

## 2.3 服务接口

**依赖注入只提供服务的功能接口**

* 封装依赖，通过提供接口来提供需要的功能

