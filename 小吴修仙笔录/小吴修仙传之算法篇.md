# 小吴修仙传之算法篇

# 数组/字符串

## 合并两个有序数组

[88. 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/)

### 1 利用 sort 函数（快排，不推荐）

1. 将数组2的数据**合并**到数组1

2. 使用 sort 函数对数组1进行**排序**

   * C++使用的是 `sort` 函数：`sort(nums1.begin(), nums1.end());`

   * Golang使用的是 `sort.Slice` 函数：`sort.Slice(nums1, func(i, j int){ return nums1[i] < nums2[j]})`

### 2 双指针，使用辅助空间（空间复杂度 O(m+n)）

1. 构建一个 `m + n` 的辅助空间
2. 利用双指针，比较 `nums1` 与 `nums2`，放到辅助空间中
3. 最后将辅助空间的数组拷贝到 `nums1` 中

### 3 逆向双指针（空间复杂度 O(1)，推荐）

**利用 nums1 中的数组尾部为空可以作为暂存的辅助空间来进行排序，先排最大的，放到辅助空间**

1. 实际是三指针

   * `nums1` 的逆向下表存储的指针（idx）：用来标记当前存放元素的位置
   * `nums1` 的数组实际下表指针（i）：用来标记比较到的位置
   * `nums2` 的数组实际下表指针（j）：用来标记比较到的位置

2. 需要考虑两种情况

   （1）`nums2` 遍历结束，`nums1` 遍历没结束（使用 `nums2` 数组的下表判断是否超出范围，超出范围直接结束，因为 `nums2` 排完序之后，`nums1` 就不需要排序了）

   <img src="D:\github\CPPStudy\src\photo\算法篇-合并数组2.png" style="zoom:50%;" />

   （2）nums1 遍历结束，但是 nums2 遍历没结束，即 nums1 的下表超出范围

   <img src="../src/photo/算法篇-合并数组1.png" style="zoom:50%;" />

   3. 从两个数组的最后向前遍历，同时移动 `idx` 指针

   ```go
   func merge(nums1 []int, m int, nums2 []int, n int)  {
       idx, i, j := m + n - 1, m - 1, n - 1
       for ; idx >= 0 && j >= 0; idx-- {
           if i < 0 && j >= 0 {
               nums1[idx] = nums2[j]
               j--
               continue
           }
           if nums1[i] >= nums2[j] {
               nums1[idx] = nums1[i]
               i--
           } else {
               nums1[idx] = nums2[j]
               j--
           }
       }
   }
   ```

## 删除有序数组中的重复项 Ⅱ

[80. 删除有序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/)

使用快慢指针：重复项，一般都需要前驱标志位来比较是否重复，重复次数，一般需要计数标志位

1. 快慢指针：快指针用来遍历数组，慢指针用来标记新数组（下一个可以放置符合条件元素的位置）
2. 前驱标志位：用来记录上一个元素的值，用来比较快指针遍历到的元素是否与上一个元素重复
3. 计数标志位：用来记录与前驱标志位重复的次数

需要判断的三种情况：

1. 重复且不超过两次的情况：不超过两次都是符合题意，使用这个元素构建新数组
2. 重复且超过两次的情况：直接跳过这个元素
3. 不相等的情况：需要同时修改前驱标志位，计数标志位，同时使用这个元素构建新数组

```go
func removeDuplicates(nums []int) int {
    count := 1
    pre := nums[0]
    left, right := 1, 1

    for ; right < len(nums); right++ {
        // 相等的情况，重复不超过两次，增加计数
        if nums[right] == pre && count < 2 {
            nums[left] = pre
            left++
            count++
        } else if nums[right] == pre && count >= 2 {   // 相等的情况，重复超过了两次，增加技术，只修改右指针
            count++
        } else {     // 不相等的情况，需要 增加计数，修改左指针，以及 pre
            nums[left] = nums[right]
            left++
            pre = nums[right]
            count = 1
        }
    }
    return left
}
```

# 双指针

## 判断子序列

[392. 判断子序列](https://leetcode.cn/problems/is-subsequence/)

双指针，直接顺序判断另一个数组中，是否按序出现子序列的所有字符

**注意**：s 长度为 0 的情况，需要判断

## 两数之和Ⅱ - 输入有序数组

[167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

双指针，从数组两端求和，向中间靠拢

* 当和大于 `target`，则右指针移动，减小 `sum`
* 当和小于 `target`，则左指针移动，增加 `sum`



# 滑动窗口

# 矩阵

# 哈希表

# 区间

# 栈

## 简化路径

[71. 简化路径](https://leetcode.cn/problems/simplify-path/)

将路径节点根据条件出栈入栈

注意：C++ 需要自己实现 `split`，因此要注意最后一个节点不能通过 `'/'` 去判断的情况

Golang 要注意一个问题，使用 `Split` 之后，会切分出 `""` 的情况，所以需要判断

# 链表

# 二叉树

# 二叉树层序遍历

# 二叉搜索树

# 图

# 图的广度优先搜索

# 字典树

# 回溯

# 分治

# Kadane算法

# 二分查找

# 堆

# 位运算

# 数学

# 一维动态规划

#  多维动态规划



