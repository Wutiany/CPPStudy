# 小吴修仙传之计算机基础篇

# 计算机网络

# 操作系统

# 数据库

## Redis

### 1. Redis 的常用数据结构

**string（Simple Dynamic String，SDS）**

简单的动态字符串等同于 C 语言中的 `char *`，可以存储任意二进制数据，不需要使用 `'\0'` 来标记结束，所以会有一个标记长度的字段，类似于 `string`

```c
struct sdshdr {
    int len;	 // 记录已经使用的长度
    int free;    // 记录 buf 数组中未使用的字节数量
    char buf[];  // 用以保存字符串
}
```

从数据结构可以看出：

1. 获取长度为 O(1)
2. 超过长度需要扩容的情况，会进行重新**申请内存**然后**拷贝**数据
3. 减少长度的时候，不需要进行删除，只需要修改 `free` 和 `len`，减少**内存分配**的次数
4. `char` 数组存储，所以**二进制类型安全**（`value` 为 `int` 的时候时候，执行 `incr` 不影响实际结果）
5. 兼容部分 C 字符串函数

应用场景：

1. 单值存储
2. 对象缓存：`value` 为 `json` 转成的字符串
3. 分布式锁：`SETNX key value`，`SETNX` 并发安全，如果有用户在使用，会返回 `false`
4. 计数器：使用 `incr`
5. 分布式系统全局序列号：同过 `incr` 原子性，获取**全局唯一**的序列号

**list**

list 节点的低层结构

```c
typedef struct listNode {
    // 前置节点
    struct listNode *prev;
    // 后置节点
    struct listNode *next;
    // 节点的值
    void *value;
} listNode;
```

list 低层结构

```c
typedef struct list {
    // 表头节点
    listNode *head;
    // 表尾节点
    listNode *tail;
    // 链表所包含的节点数量
    unsigned long len;
    // 节点值复制函数
    void *(*dup)(void *ptr);
    // 节点值释放函数
    void (*free)(void *ptr);
    // 节点值对比函数
    int（*match）(void *ptr, void *key);
} list;
```

从结构体可以看出：

1. 节点使用**双向指针**的原因，所以支持**反向遍历**
2. list 结构有头节点和尾节点，所以在插入、删除、查询的时候，都可以从头尾开始
3. 获取长度 `O(1)`
4. 存储的值是 `void *`，所以可以保存不同的值

**注意**：表头前置节点指向 NULL，表位节点指向 NULL，所以 Redis 的链表实现的是**无环链表**

应用场景：

1. 模拟分布式系统数据结构：栈、队列、阻塞队列
1. 消息队列：发布与订阅、慢查询
1. 微博、朋友圈、公众号等，关注的文章列表显示：链表存储数据结构（最新的显示，头插法）

**hash** 

类似与 C++ 的 map 结构

```c
// 字典的结构
typedef struct dictht {
    // 哈希表数组
    dictEntry **table;
    // 哈希表大小
    unsigned long size;
    // 哈希表大小掩码，用于计算索引值
    // 总是等于size-1
    unsigned long sizemark;
    // 该哈希表已有节点的数量
    unsigned long used;
} dichht;
```

从结构体可以看出：

1. 哈希冲突的解决方法：链地址法
2. 字典带有两个 `hash` 表，一个平时使用，一个进行 `rehash` 使用
3. 使用 MurmurHash2 来计算**键**的**哈希值**：即使属于的键是规律的，算法也能给一个很好的随机性

**注意**：**过期功能**不能使用在字段上，只能使用在键上；集群架构下不适合他规模使用，因为单个哈希表键值多的话，会造成很大的压力

应用场景：

1. 电商购物车
2. 购物车操作：`hset hincrby hlen hdel hgetall`

**set**

不允许 `key` 重复，否则**设置无效**

应用场景：

1. 抽奖获取
2. 朋友圈点赞
3. 利用 set 的交、并、差集实现微博、微信关注模型：`sinter sunion sdiff `

**zset（有序集合）**

比 set 多一个 `score` 分值，根据这个 `score` 进行排序 

应用场景：

1. 实现热搜排行榜（排行榜之类的）

**跳跃表**

`zset` 的**低层实现**；多层结构，高层跨多个指向

```C
typedef struct zskiplistNode {
    // 后退指针
    struct zskiplistNode *backward;
    // 分值 权重
    double score;
    // 成员对象
    robj *obj;
    // 层
    struct zskiplistLevel {
        // 前进指针
        struct zskiplistNode *forward;
        // 跨度
        unsigned int span;
    } leval[];
} zskiplistNode;
```

```c
typedef struct zskiplist {
    // 表头节点和表尾节点
    struct zskiplistNode *header, *tail;
    // 表中节点的数量
    unsigned long length;
    // 表中层数最大的节点的层数
    int leval;
} zskiplist;
```

从结构体可以看出：

1. 跳表又两个数据结构组成，`zskiplist` 结构是用来存储不同层的信息的（前后节点指向，节点的数量，表中最大层数），`zskiplistNode` 是每个跳表的节点
2. 每个跳表节点的层高是 1 至 32 之间的随机数
3. 在同一个跳表中，多个节点可以包含相同的 score，但每个节点的成员对象必须是唯一的
4. 跳表中节点按照分值大小进行排序的，分值相同时，按照成员对象的大小进行排序

**注意**：为了避免插入操作的时间复杂度是O(N)，`skiplist` 每层的数量不会严格按照2:1的比例，而是对每个要插入的元素随机一个层数

# 数据结构



