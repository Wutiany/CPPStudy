# 小吴修仙传之计算机基础篇

# 计算机网络

# 操作系统

### 1. 进程、线程和协程的区别和联系

**定义：**

1. **进程**是**资源**分配的和拥有的**基本单位**
2. **线程**是**程序执行**的**基本单位**
3. **协程**是**用户态**的轻量线程，**线程内部**调度的**基本单位**

**依附关系：**

1. **线程**依附于**进程**，一个线程可以拥有多个进程，由**内核调度**
2. **协程**是用户态轻量线程，依附于**线程**，由**线程调度**

**并发性：**

1. **进程**并发通过进程间切换实现，通过 CPU 实现并行
2. **线程**并发同样是线程间切换，通过 CPU 实现并行
3. **协程**不支持并发，线程中的多个协程，同时只有一个可以执行

**系统开销：**

1. **进程**的创建、销毁、切换的开销大，因为需要切换和保存的内容较多，也涉及到内存分配
2. **线程**的创建、销毁、切换的开销较小，仅涉及程序计数器、少量寄存器和栈内容
3. **协程**由于是用户态，所分配的资源少，所以开销是**最小的**

**调用栈：**

1. **进程**拥有**内核栈**
2. **线程**同样拥有**内核栈**，同时共享进程的资源
3. **协程**是**用户栈**

### 2. 一个进程创建线程的最大数量

**与系统有关（用户态虚拟内存）**

1. 32 位系统，用户态的虚拟空间只有 3G，如果创建的线程时分配的栈空间时 10M，一个进程最多能创建 300 个左右。
2. 64 位系统，用户态的虚拟空间最大有 128T，所需不受虚拟内存大小的限制

**与线程创建时的栈空间分配也有关**

线程的栈空间大小是可以设置的

### 3. 进程调度算法

1. **先来先服务**（first-come first-serverd，FCFS）

   **非抢占式**的调度算法，顺序执行。

   有利于长作业，不利于短作业。因为短作业需要一直等待长作业完成，导致短作业等待时间过长

2. **短作业优先**（shortest job first，SJF）

   **非抢占式**的调度算法，按估计运行时间最短的顺序执行。

   可能导致长作业饥饿（一直有短作业到来的情况，导致长作业长时间无法执行）

3. **最短剩余时间优先**（shortest remaining time next，SRTN）

   最短作业优先的**抢占式**调度算法，通过剩余时间比较来进行抢占式执行，谁剩余时间少，谁执行，其于被挂起

4. **时间片轮转**

   在 FCFS 的基础上，每个进程 CPU 分配一个时间片，用来执行，到时间片到期，重新放到队尾等待下一轮执行

5. **优先级调度**

   每个进程拥有一个优先级，按找优先级进行调度

   为了防止低优先级**饥饿**，随时间推移**增加**等待进程的**优先级**

6. **多级反馈队列**

   改进时间片轮转**频繁切换**的问题（连续执行多个时间片的进程）

   构建多级队列（每个队列所给予执行的时间片数量不同：数量递增，同时优先级不同，时间片越少的队列，优先级越高），在当前队列被执行完，放到下一个队列（时间片分配更多的队列）

### 4. Linux 下进程间通信的方式

1. 管道
   * 无名管道（内存文件）：半双工，由于无名的原因，仅限于有亲缘关系（继承关系）的进程之间使用
   * 有名管道（FIFO文件，借助文件系统）：借助文件系统，所以非亲缘关系也能使用
2. 共享内存：映射一段能被其他进程所访问的内存。共享内存是最快的 IPC 方式
3. 消息队列：消息链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
4. 套接字：同机器与不同机器之间进程通信
5. 信号：单一消息传递
6. 信号量：相当于计数器，往往与锁进行结合，控制多个进程间对共享资源的访问。





# 数据库

## Redis

### 1. Redis 的常用数据结构

**string（Simple Dynamic String，SDS）**

简单的动态字符串等同于 C 语言中的 `char *`，可以存储任意二进制数据，不需要使用 `'\0'` 来标记结束，所以会有一个标记长度的字段，类似于 `string`

```c
struct sdshdr {
    int len;	 // 记录已经使用的长度
    int free;    // 记录 buf 数组中未使用的字节数量
    char buf[];  // 用以保存字符串
}
```

从数据结构可以看出：

1. 获取长度为 O(1)
2. 超过长度需要扩容的情况，会进行重新**申请内存**然后**拷贝**数据
3. 减少长度的时候，不需要进行删除，只需要修改 `free` 和 `len`，减少**内存分配**的次数
4. `char` 数组存储，所以**二进制类型安全**（`value` 为 `int` 的时候时候，执行 `incr` 不影响实际结果）
5. 兼容部分 C 字符串函数

应用场景：

1. 单值存储
2. 对象缓存：`value` 为 `json` 转成的字符串
3. 分布式锁：`SETNX key value`，`SETNX` 并发安全，如果有用户在使用，会返回 `false`
4. 计数器：使用 `incr`
5. 分布式系统全局序列号：同过 `incr` 原子性，获取**全局唯一**的序列号

**list**

list 节点的低层结构

```c
typedef struct listNode {
    // 前置节点
    struct listNode *prev;
    // 后置节点
    struct listNode *next;
    // 节点的值
    void *value;
} listNode;
```

list 低层结构

```c
typedef struct list {
    // 表头节点
    listNode *head;
    // 表尾节点
    listNode *tail;
    // 链表所包含的节点数量
    unsigned long len;
    // 节点值复制函数
    void *(*dup)(void *ptr);
    // 节点值释放函数
    void (*free)(void *ptr);
    // 节点值对比函数
    int（*match）(void *ptr, void *key);
} list;
```

从结构体可以看出：

1. 节点使用**双向指针**的原因，所以支持**反向遍历**
2. list 结构有头节点和尾节点，所以在插入、删除、查询的时候，都可以从头尾开始
3. 获取长度 `O(1)`
4. 存储的值是 `void *`，所以可以保存不同的值

**注意**：表头前置节点指向 NULL，表位节点指向 NULL，所以 Redis 的链表实现的是**无环链表**

应用场景：

1. 模拟分布式系统数据结构：栈、队列、阻塞队列
1. 消息队列：发布与订阅、慢查询
1. 微博、朋友圈、公众号等，关注的文章列表显示：链表存储数据结构（最新的显示，头插法）

**hash** 

类似与 C++ 的 map 结构

```c
// 字典的结构
typedef struct dictht {
    // 哈希表数组
    dictEntry **table;
    // 哈希表大小
    unsigned long size;
    // 哈希表大小掩码，用于计算索引值
    // 总是等于size-1
    unsigned long sizemark;
    // 该哈希表已有节点的数量
    unsigned long used;
} dichht;
```

从结构体可以看出：

1. 哈希冲突的解决方法：链地址法
2. 字典带有两个 `hash` 表，一个平时使用，一个进行 `rehash` 使用
3. 使用 MurmurHash2 来计算**键**的**哈希值**：即使属于的键是规律的，算法也能给一个很好的随机性

**注意**：**过期功能**不能使用在字段上，只能使用在键上；集群架构下不适合他规模使用，因为单个哈希表键值多的话，会造成很大的压力

应用场景：

1. 电商购物车
2. 购物车操作：`hset hincrby hlen hdel hgetall`

**set**

不允许 `key` 重复，否则**设置无效**

应用场景：

1. 抽奖获取
2. 朋友圈点赞
3. 利用 set 的交、并、差集实现微博、微信关注模型：`sinter sunion sdiff `

**zset（有序集合）**

比 set 多一个 `score` 分值，根据这个 `score` 进行排序 

应用场景：

1. 实现热搜排行榜（排行榜之类的）

**跳跃表**

`zset` 的**低层实现**；多层结构，高层跨多个指向

```C
typedef struct zskiplistNode {
    // 后退指针
    struct zskiplistNode *backward;
    // 分值 权重
    double score;
    // 成员对象
    robj *obj;
    // 层
    struct zskiplistLevel {
        // 前进指针
        struct zskiplistNode *forward;
        // 跨度
        unsigned int span;
    } leval[];
} zskiplistNode;
```

```c
typedef struct zskiplist {
    // 表头节点和表尾节点
    struct zskiplistNode *header, *tail;
    // 表中节点的数量
    unsigned long length;
    // 表中层数最大的节点的层数
    int leval;
} zskiplist;
```

从结构体可以看出：

1. 跳表又两个数据结构组成，`zskiplist` 结构是用来存储不同层的信息的（前后节点指向，节点的数量，表中最大层数），`zskiplistNode` 是每个跳表的节点
2. 每个跳表节点的层高是 1 至 32 之间的随机数
3. 在同一个跳表中，多个节点可以包含相同的 score，但每个节点的成员对象必须是唯一的
4. 跳表中节点按照分值大小进行排序的，分值相同时，按照成员对象的大小进行排序

**注意**：为了避免插入操作的时间复杂度是O(N)，`skiplist` 每层的数量不会严格按照2:1的比例，而是对每个要插入的元素随机一个层数

# 数据结构



