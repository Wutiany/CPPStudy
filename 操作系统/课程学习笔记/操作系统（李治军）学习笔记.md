# 操作系统（李治军）学习笔记

## 操作系统的启动

操作系统启动前是先加载引导扇区（bootsect.s），通过引导扇区把 `setup` 和操作系统加载进内存

* `setup, setup.s`
  * 扩展内存，将 `16` 位寻址（实模式，只能访问 `1M` 内存），转换成 `32` 位（`4G`）寻址（保护模式可以访问 `4G` 内存）
  * 将操作系统移到 `0`（转换后的地址） 地址处
  * 进入保护模式（`32` 位寻址模式）
  * `setup` 结束
* 硬件通过 `gdt` （全局描述符表）来产生 `32` 位地址
  * 优点：快，因为是硬件驱动
* `system` 模块
  * `head.s` 再次初始化 `gdt` 表
  * 设置一些数据结构，压栈
  * 执行`main.c`，死循环执行，`main.c` 表示操作系统启动
  * 同时 `main.c` 会初始化硬件，调用 `mem_init` 将内存数据初始化为 `0`（每 `4k page` 清除一次）



## 操作系统接口

操作系统接口就是表现成一些函数，调用函数就进入到操作系统内部

### 命令行

* 命令行其实就是函数，通过调用 `fork()` 去执行一个新的进程
* `shell` 也是一段程序：`/bin/sh`

### 图形按钮

* 图形界面就是一个包括画图的 `C` 程序

### 系统调用函数

POSIX 操作系统同一的接口标准（跨平台）



## 系统调用的实现

### 程序的状态以及隔离级别

通过程序的状态以及隔离级别来将内核程序与用户程序进行 **隔离**

* 程序分为 **内核态** 和 **用户态**，其中 `CS:CP` 是当前指令，`CS` 的最低两位来表示级别（0 是内核态，3 是用户态）
* 特权级别
  * `CPL, Current Privilege Level` 当前程序的特权级别。CPL 是用来表示当前 CPU 执行指令时所处特权级别的值
  * `RPL, Requested Privilege Level` 请求的特权级别。RPL 是指在 CPU 执行 CALL 或 JMP 指令时，指令中所指定代码段的特权级别
  * `DPL, Descriptor Privilege Level` 描述符特权级别。DPL 是指描述符中的访问权限所对应的特权级别
* `DPL ≥ CPL，DPL ≥ RPL` 才能够执行，即（内核态可以访问任何数据，用户态不能访问内核数据，同样跳转指令也实现隔离，跳转指令不能被用户态所使用）

### 用户态访问内核数据

* 用户态只有通过 `int 0x80(中断)` 进入内核态，调用中断处理函数。通过调用 `system_call` 去处理中断

* `用户调用 printf-> printf 展成 int 0x80 -> 中断处理 system_call -> 查表 sys_call_table -> __NR_write = 4 -> 调用 sys_write`



## CPU管理的直观想法

* `CPU` 根据 `PC=50` 通过总线去内存为 `50` 的地方取出汇编指令进行执行。`PC` 自动累加

*  `I/O` 时间长，`CPU` 为了提高率用来会切换到其他程序执行

  * `I/O` 结束之后，如何唤醒 `CPU` 回来：

    如果在 `I/O` 操作期间，`CPU` 需要执行另一个程序，例如中断处理程序，那么操作系统会保存当前程序的上下文（如程序计数器、寄存器等），并切换到中断处理程序的上下文，让其执行。中断处理程序执行完成后，操作系统会再次切换回原来程序的上下文，让其继续执行。

    在这个过程中，操作系统需要维护一个进程控制块（`PCB`），用于保存每个进程的上下文信息，包括程序计数器、寄存器、内存分配情况等，以便在进程之间进行切换时能够正确地保存和恢复进程的状态。



## 多进程图像

* `PCB, Process Control Block`：用来记录进程信息的数据结构
* 多进程的组织：PCB + 状态 + 队列
*  状态（新建态，就绪态，运行态，阻塞态，终止态）
* 进程的切换通过 `schedule()` 函数来进行。
  * 其中的 `switch_to()` 函数通过 PCB 数据结构将当前线程的数据（CPU寄存器中的数据）存储，然后载入新线程 PCB 数据，来做到进程切换的功能
* 多进程为了防止进程修改其他进行地址的数据，使用 **映射表** 来进行地址空间分离（后续内存管理部分）



