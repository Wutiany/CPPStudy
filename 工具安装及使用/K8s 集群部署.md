# K8s 集群部署

# 1 预备内容

## 1.1 需要设备

**虚拟机**

* 使用虚拟机来进行**多个系统**模拟

**系统环境**

* 虚拟机中使用 `centos7`

**软件需求**

* 使用 `k8s` 部署集群，就需要**每个系统**中都安装 `k8s`，以及 `docker`
  * **k8s**
  * **docker**

**集群节点规划**

* host 配置，标记集群不同节点，用来进行通讯（hostname : ip）
* 节点配置
  * k8s-master：集群主节点（对应 ip）
  * k8s-node：集群其他节点（对应 ip），有多个

## 1.2 配置步骤

* **所有集群节点**进行初始化配置（系统配置）
  * **关闭防火墙（firewall）**：不拦截通信
  * **关闭安全模块（selinux）**：关闭**强制访问控制**
  * **关闭 linux 内存交换（swap）**：虚拟内存机制，用来将不用的内存数据写回磁盘，关闭提高性能（详细参见[关闭 swap](#*.1-关闭 swap)）
  * **设置主机名**：用来进行标记通讯（DNS）
  * **在 master 节点中添加 hosts**：用来对其他节点进行访问
  * **将桥接的 IPv4 流量传递到 iptables 的链**：因为使用的是虚拟机，所以需要操作一下。（[iptables](#iptables)）
  * **时间同步**
  * **安装 docker、kubeadm、kubelet、kubectl**
    * docker 配置镜像源
    * k8s 添加软件源
* **master** 节点部署
  * `kubeadm` 部署（初始化，**初始化后保存一下 join 的 token**）
  * 拷贝 `k8s` 认证文件
* **配置 node 节点**（配置 and 加入集群）
  * 向集群中添加新节点（**master 节点 init 之后输出的 kubeadm join 命令**）
    * `token` 24 小时有效，快捷生成的方法 `kubeadm token create --print-join-command`
* **部署 CNI 网络插件**：用于 `pod` 资源**跨宿主机通信**
  * 下载配置文件（在 master 节点中）：`wget https://docs.projectcalico.org/manifests/calico.yaml`
  * 修改配置文件内容
  * 使用配置文件进行部署
* **部署 Dashboard**：用来可视化管理 k8s 资源
  * 下载配置文件： `wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.4.0/aio/deploy/recommended.yaml`
  * 修改配置文件：暴露端口
  * 访问地址：https://NodeIP:30001 
  * 创建 `service account` 同时绑定默认集群管理员角色
  * 创建用户：使用 `kubectl` 创建
  * 用户授权：同样使用 `kubectl`
  * 获取 `token`：用来登入 `Dashboard`

# 2 实际配置流程





[参考文档](https://cloud.tencent.com/developer/article/2160663)

# * 知识学习

## *.1 关闭 swap

> Swap 是 Linux 系统中的一种虚拟内存机制，它允许将内存中暂时不使用的数据写入到硬盘上的交换空间（swap space）中，以释放物理内存供其他进程使用。
>
> Swap 的主要作用包括：
>
> 1. 内存扩展：当系统的物理内存不足时，Swap 提供了一种扩展内存容量的方式。它允许将较少使用的数据存储在交换空间中，从而将物理内存腾出来供更活跃的进程使用。
> 2. 内存回收：Swap 可以作为一种内存回收机制，将不常用的数据从内存中迁移到交换空间，以释放物理内存。这有助于避免系统出现内存压力和溢出的情况。
>
> 尽管 Swap 在某些情况下提供了一种弥补物理内存不足的机制，但在构建集群时，通常建议关闭 Swap。这是因为集群环境通常要求高性能和可预测的性能延迟，而 Swap 可能引入额外的性能开销和不可预测的行为。
>
> 关闭 Swap 的主要原因包括：
>
> 1. 避免性能问题：Swap 的使用会导致额外的磁盘 I/O 操作，可能会对系统性能产生负面影响，尤其是在高负载情况下。
> 2. 避免不可预测的延迟：当系统出现内存压力时，使用 Swap 可能导致进程的延迟增加，因为数据需要从硬盘中读取回到内存中。
> 3. 内存管理简化：关闭 Swap 可以简化内存管理，使系统的行为更加可预测和稳定。
>
> 需要注意的是，在某些特定的使用场景下，如内存密集型应用或需要大量临时存储空间的情况下，Swap 可能仍然有其用途。在这种情况下，可以根据具体需求和性能测试结果来决定是否启用 Swap，并调整 Swap 的配置参数以达到最佳性能和稳定性。

## *.2 iptables

> 在 Linux 系统上，iptables 是一个用于配置和管理防火墙规则的工具。iptables 使用一系列称为 "链"（Chains）的逻辑组件来处理网络数据包。
>
> 链是一组规则的集合，用于决定如何处理进入或离开系统的网络数据包。每个数据包在经过防火墙时，会依次经过一系列预定义的链，直到匹配到适用的规则，或者到达链的末尾。
>
> 以下是一些常见的iptables 链：
>
> 1. INPUT：INPUT 链用于处理进入系统的数据包。它决定是否接受或拒绝进入系统的数据包。
> 2. OUTPUT：OUTPUT 链用于处理离开系统的数据包。它决定是否允许或阻止离开系统的数据包。
> 3. FORWARD：FORWARD 链用于处理不在本地系统上的数据包，即转发数据包。它决定是否允许或阻止转发到其他网络的数据包。
> 4. PREROUTING：PREROUTING 链用于在网络数据包到达防火墙之前进行处理。它通常用于对数据包进行网络地址转换（NAT）操作。
> 5. POSTROUTING：POSTROUTING 链用于在网络数据包离开防火墙之前进行处理。它通常用于对数据包进行网络地址转换（NAT）操作。
>
> 这些是iptables 的一些默认链，但你也可以创建自定义链来满足特定的需求。自定义链可以将一组规则组织在一起，以便更好地管理和维护防火墙规则。
>
> 每个链中可以包含多个规则，这些规则定义了如何处理特定类型的数据包。规则可以指定数据包的来源、目标、协议、端口等属性，并指定允许、拒绝、重定向等操作。
>
> 通过配置适当的链和规则，可以使用iptables 对网络数据包进行高级的过滤、转发、地址转换等操作，从而实现更精确的网络安全和流量控制。

## *.3 kubectl、kubeadm、kubelet

> kubectl、kubeadm 和 kubelet 是 Kubernetes 中的三个核心组件，它们各自承担着不同的功能和职责。
>
> 1. kubectl：kubectl 是 Kubernetes 的命令行工具，用于与 Kubernetes 集群进行交互和管理。通过 kubectl，管理员和开发人员可以执行各种操作，包括创建、删除、更新和管理 Kubernetes 资源（如 Pod、Service、Deployment 等），查看集群状态，进行日志和事件查询，进行扩展和调整等。kubectl 是与 Kubernetes API 交互的主要方式，提供了丰富的命令和选项，用于管理和操作 Kubernetes 集群。
> 2. kubeadm：kubeadm 是 Kubernetes 提供的用于初始化和管理 Kubernetes 集群的命令行工具。它简化了 Kubernetes 集群的部署和配置过程，提供了一致性和可重复性的方式来设置和管理集群的各个组件。kubeadm 可以通过一系列命令来初始化控制平面节点、加入节点、生成配置文件、安装网络插件等。它还负责验证集群的状态和配置，以确保集群的正确性和一致性。
> 3. kubelet：kubelet 是运行在每个 Kubernetes 节点上的主要组件，负责管理和监控节点上的容器和 Pod。kubelet 从 API Server 接收 Pod 的定义，并负责创建、启动、停止和监控 Pod 的生命周期。它还负责执行容器的健康检查、资源管理、容器日志收集等任务。kubelet 与容器运行时（如 Docker、containerd）进行交互，确保容器按照所需的状态运行，并与其他 Kubernetes 组件协同工作，以维护整个集群的状态和稳定性。
>
> 综上所述，kubectl 是 Kubernetes 的命令行工具，用于与集群进行交互和管理；kubeadm 是用于初始化和管理 Kubernetes 集群的工具；kubelet 是运行在每个节点上的组件，负责管理和监控节点上的容器和 Pod。这三个组件共同协作，实现了 Kubernetes 集群的创建、配置、管理和运行。