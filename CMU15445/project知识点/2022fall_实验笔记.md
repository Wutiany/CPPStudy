# 2022fall_实验笔记

## project_0 - trie tree

### 实验目的

* 实现一个存储字符串的 `trie` 树，同一个单词的同一个位置如果字母相同，使用同一个 `node`，最终的节点存储字符串键对应的 `value`，用来判断。

### 实验内容

* 根据数据结构需要实现三个部分：
  * `TrieNode` 类：trie 树的每个基本的节点
  * `TrieNodeWithValue` 类：`TrieNode` 的子类，用于表示每个单词结尾字母的 `kv` 结构
  * `Trie` 类：用于组织节点，并不同于存储任何 `kv`，增删改查。注意不允许插入重复的键。
  * 并发操作：通过加入 lock 实现 `trie` 树的并发

### 实现要点

#### TrieNode

* 类的初始化
  * 初始化节点存储的 `key` ，即 `char`
  * 初始化 `end` 标识
  * 清理存 `children` 节点的容器

* 移动构造函数
  * 容器内容交换用到了容器的方法 `swap`

* 为当前节点插入给定 `key` 的子节点
  * 需要判定当前节点是否有这个 `key` 的子节点，以及给定子节点的 `key` 和子节点的 `key` 是否对应
  * 在子节点存储在子节点容器中使用了 `std::forward`（完美转发），**保持保证原始参数类型不变，可以避免在函数调用的时候发生不必要的拷贝和移动**


#### TrieNodeWithValue

* 继承自 `TrieNode` 类，与父类不同的是，这个节点是用来存储每个单词对应的 `value` 的，所以增加了成员变量 `Value_`
* 该节点使用的条件
  * 本身这个节点已经存在，但是不是一个字符串的结尾，插入的新字符串在这个节点结尾，需要替换节点
    * 移动构造函数（将 `TrieNode` 类型节点转换成 `TrieNodeWithValue` 类型），其中用到了完美转发，将传入的 **`TrieNode` 右值引用**转发给父类的移动构造函数
      * 函数体内需要修改 `value` 以及标记 `end` 节点（通过调用父类的方法）
  * 本身不存在这个节点，可以直接使用 `TrieNodeWithValue` 来作为子节点
    * 构造函数，实际不适用，在后续的 Trie 树插入代码中，使用了TrieNode类的

#### Trie

* 为了使 Trie 树可以作为 `26` 个字母为起始节点的存储树，需要将根节点设置为 `'\0'`，这样根节点可以指向 `26` 个字母
  * 涉及到独占指针更换指向的问题，使用 `reset` 方法

* Trie 树需要提供插入、删除和查找的操作
  * 插入操作
    * 遍历字符串，去查找 Trie 树中有没有 `char` 的节点，没有就创建，有就递归到下一个，一直找到最后一个位置的节点，但是不创建最后一个 `char` 对应的节点，或者不找到最后一个 `char` 对应的子节点（通过判断当前节点的下个一节点是否是字符串的结尾，如果是，就停止遍历，这时节点就停在了倒数第二个 `char` 上了），因为需要根据最后一个节点的类型去判定是创建新节点还是转换节点类型
    * 获取最后一个字符的节点，判断这个节点的状态
      * 首先判断无法插入的状态（即有这个节点，但是是 `end` 节点）
      * 然后在判断其他的情况
      * **注意：独占指针的 `get()` 方法是获取其中对象的指针**
      * **注意：只能操作指向独占指针的指针**
  * 删除操作
    * 链表类型的删除，可以通过差分节点记录来删除即（<前一节点，下一节点>这种节点入栈，从栈顶找到倒数第二个节点以此类推进行删除下一个节点）
    * 遍历字符串，在 `Trie` 树中找到所有节点，如果没找到就 `return`，遍历需要存储前一节点以及对应的下一个节点
    * 出栈删除节点，在获取节点的时候使用了 `std::get<0>(tuple)` 获取 `tuple` 的内容（提高代码可读性和可维护性）（不满足节点使用 `continue` 跳出当前循环继续向下找，满足条件删除，和压栈是否的方法相同，有子节点压栈 `continue`，不满足返回 `false`）
  * 查询操作
    * 查询操作和插入操作大致相似，但是不会去在字符串到结尾就跳出，因为要获取最后的节点
      * 涉及了一个指针的转换 `dynamic_cast`

#### 并发操作

* 只需要在 Trie 树的插入删除查询操作的增加读写锁来达到一致性的问题
  * 需要注意的是，只要有 `return` 就要在 `return` 之前解锁，防止死锁
  * 可以使用 `std::scoped_lock` 去解锁，使用这个之后需要自己声明 `mutex`，用来加共享锁



## project_1 - buffer_pool

### 实验目的



### 实验内容



### 实验要点

