# C++ 八股

## 区别问题八股

### 1.指针与引用之间的区别

* 本质区别
  * 指针为**变量**存储的是一个地址；引用为**别名**
* 使用区别
  * 初始化方面：
    * 指针可以不同初始话（可以为空），后续赋值；引用必须初始化（不能为空）
  * 后续使用方面：
    * 指针可以改变指向；引用初始化后不能改变指向
    * 指针可以多级指向；引用只能一级指向
  * 作为参数传递的方面：
    * 指针为变量，传递的时候是值拷贝，所以在函数中改变指向，不影响原指针的指向；引用为变量别名，不能改变指向

### 2.new 和 malloc 的区别

* 本质区别
  * new 是运算符，支持重载；malloc 为标准库函数，可以覆盖
* 使用区别
  * 初始化方面：
    * new 根据类型进行分配空间；malloc 只分配指定大小的内存块
    * new 在分配内存的时候会调用复杂类型的构造函数；malloc 仅仅只是分配内存
  * 返回值方面：
    * new 返回类型的指针，不需要进行指针的类型转化；malloc 返回 `void *` 指针，需要进行指针类型转化，不安全

### 3.宏定义和函数的区别

* 本质区别
  * 宏定义是进行文本替换；函数是进行函数调用

* 使用区别
  * 宏定义的的替换发生在预处理阶段；函数调用发生在编译阶段
  * 宏定义属于在结构中中快速插入代码，没有返回值；函数调用具有返回值
  * 宏定义参数没有类型，不进行类型检查；函数参数会进行类型检查
  * 宏定义不是语句，所以不需要在最后加 `;`

### 4.宏定义和 typedef 的区别

* 本质区别
  * 宏定义是进行文本替换；typedef 是类型定义
* 使用区别
  * 宏定义发生在预处理阶段，进行文本替换；typedef 是编译的一部分
  * 宏不会进行类型检查；typedef 会进行类型检查
  * 宏不是语句，不需要在结尾加 `;`；typedef 是语句，需要在结尾加 `;`
  * 宏定义没有作用域的概念；typedef 有作用域的概念

### 5.变量的声明和定义的区别

* 本质区别
  * 声明只是把变量声明的位置传递给编译器，并不分配内存空间；定义需要分配内存空间
* 使用区别
  * 相同的变量可以多处声明；定义只能定义一次

### 6.strlen 和 sizeof 的区别

* 本质区别
  * strlen 是库函数，支持覆盖；sizeof 是运算符
* 使用区别
  * strlen 传入的参数只能是字符串，而且结尾需要有 `'\0'` 来标识结尾；sizeof 可以传入任何类型的参数
  * sizeof 的结果是编译时确定的，所以不能用来获取动态分配（运行时分配）存储空间大小 

### 7.指针常量和常量指针的区别

* 本质区别
  * 指针常量，常量修饰的是指针指向的内容；常量指针，常量修饰的是指针
* 使用区别
  * 指针常量指向的对象是个常量，指向的对象不可改变；常量指针，这个指针是常量，指针的指向不可改变

### 8.a 和 &a 的区别

**如果 a 为数组，int a[10]；int (*p)[10]=&a**

* 本质区别：
  * a 为数组名，即首元素地址，+1 可以取偏移量取下一个位置的元素；&a 为 int(*p)[10] 的数组的指针，+1 是偏移这个数组的一个长度即 10 的元素的长度
  * 解引用的时候 (int *)p，输出 *p，是 int 型的大小进行读取

### 9.指针参数传递和引用参数传递的区别

* 本质区别
  * 指针参数传递本质是值传递；引用参数传递是间接寻址，存储的是主调函数比实参变量的地址，通过别名去主调函数中寻找变量
* 使用区别：
  * 指针参数相当于值传递，拷贝的副本，对这个指针进行操作（转换指向）不影响原指针的指向；引用参数传递相当于主调函数变量的一个别名，对其所有的操作都会影响主调函数中的变量。
* 编译角度的区别：
  * 指针添加到符号表中，符号表上对应的是地址值为指针变量的地址值；引用添加到符号表，符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）
  * 符号表生成后就不会在修改，所以指针的指向是可以改变的（指针变量的地址值不变，但是地址对应的指针指向可以改变），引用不可改变，变量地址已经确定

### 10.define、const、typedef、inline 的使用方法以及之间的区别

* const 和 #define 的区别
  * 本质区别：
    * const 是关键字，发生在编译链接阶段，定义常量，存储在数据段；#define 是宏定义，发生在预处理阶段，进行文本替换，定义常数，不带类型，预处理后存储在代码段
  * 使用区别：
    * const 不能重定义；#define 可以使用 #undef 进行取消定义
    * const 会进行类型检查；#define 只是简单的文本替换，不会进行类型检查
    * #define 有独特的作用：防止文件被重复引用
* typedef 和 #define 的区别
  * 本质区别：
    * typedef 是关键字，发生在编译阶段，进行类型定义；#define 是宏定义，发生在预处理阶段，进行文本替换
  * 使用区别：
    * typedef 进行类型检查；#define 不进行类型检查
    * typedef 用来定义类型别名，定义与平台无关的数据类型；#define 不仅能为类型取别名，还能定义常量、变量、编译开关等；
    * typedef 有作用域限制；#define 没有作用域限制
* inline 和 #define 的区别
  * 本质区别：
    * inline 是函数，在编译阶段进行替换；#define 是关键字，在预处理阶段进行替换
  * 使用区别：
    * inline 有类型检查；#define 没有类型检查

### 11.定义和声明的区别（变量和函数）

* 针对变量
  * 从编译原理上来说，声明只是告诉编译器，某个变量会被使用，但是编译器不会为其分配内存。定义就是分配内存
* 针对函数
  * 声明一般在头文件中，告诉编译器有函数存在
  * 定义一般在源文件中，是具体函数的实现过程，即函数体的书写

### 12.全局变量（普通函数）和 static 变量（函数）的区别

* 作用域上
  * 全部变量的作用域在整个源程序；增加了 static 的静态变量，作用域在当前文件，同时可以用来隐藏数据，是其他文件无法访问
  * 普通函数的作用域依旧是整个源程序（通过头文件的引用来使用）；static 函数的作用域在当前源文件，static 函数也叫内部函数
* 初始化和存储上
  * static 变量只初始化一次；
  * static 函数在内存中只有一份；普通函数在每个被调用中维持一份拷贝程序的局部变量存在于**堆栈**中，全局变量存在于**静态区**中，动态申请数据存在于**堆**中

### 13.静态成员与普通成员的区别

* 生命周期
  * 静态成员变量的声明周期和类存在的生命周期相同，一直存在
  * 普通成员变量的声明周期和对象的声明周期相同（随对象的创建而产生，对象的销毁而销毁）
* 共享方式
  * 静态成员变量是全类共享
  * 普通成员变量是是每个对象但是使用
* 定义位置
  * 静态成员变量存储在全局区或者数据区
  * 普通成员变量存储在堆栈中
* 初始化
  * 静态成员变量在类外初始化
  * 普通成员变量在类中初始化
* 使用上
  * 静态成员变量可以作为默认实参



## 特性八股

### 1.运算符重载

* 运算符重载的原因：
  * 实现类的多态

* 运算符重载的方式：
  * 成员运算符重载和非成员运算符重载，成员运算符重载时，会少一个参数，因为 this 指针绑定的左侧的对象
  * 只能重载已有的运算符，同时只能重载其内部逻辑，**不能更**改优先级和结合律，**更不能改**操作数的个数
  * 下表运算符必须是成员函数，通常以访问元素的引用作为返回值，最好同时定义下标运算符的常量版本和非常量版本
  * 箭头运算符也必须是类成员函数，解引用通常也是类的成员，同时重载的箭头运算符必须返回类指针
* 运算符种类判断（同种运算符既是一元运算符又是二元运算符）
  * 通过参数的个数进行推断

### 2.存在函数重载时，函数的匹配原则和顺序是什么

* 名字查找
* 确定候选函数
* 寻找最佳匹配

### 3.隐式转换是什么，如何消除隐式转换

* 不同类型的隐式转换
  * 基本类型的隐式转换：编译器私下进行的隐式转换
  * 类的隐式转换：在返回时，使用子类返回一个父类类型
* 隐式转换的形式
  * 基本类型的隐式转换：小 -> 大进行转换，保证**精度不丢失**
  * 类类型的隐式转换：子类 -> 父类进行转换，父类转子类，访问不到子类重新定义的变量
* 消除隐式转换的方式
  * 使用 explicit 关键字，构造函数加上 explicit，能够禁止隐式转换
  * 构造函数只接受一个参数，实际上就定义了转换为此类类型的隐式转换机制，相当于通过返回值的传递参数，构造一个返回类型的类的临时变量。通过使用 explicit（只对一个实参构造有效，多参的构造，如果除第一个形参外，其他形参都有默认参数，也可以使用）来防止隐式转换



## 标准库八股
