# C++ 八股

## 区别问题八股

### 1.指针与引用之间的区别

* 本质区别
  * 指针为**变量**存储的是一个地址；引用为**别名**
* 使用区别
  * 初始化方面：
    * 指针可以不同初始话（可以为空），后续赋值；引用必须初始化（不能为空）
  * 后续使用方面：
    * 指针可以改变指向；引用初始化后不能改变指向
    * 指针可以多级指向；引用只能一级指向
  * 作为参数传递的方面：
    * 指针为变量，传递的时候是值拷贝，所以在函数中改变指向，不影响原指针的指向；引用为变量别名，不能改变指向

### 2.new 和 malloc 的区别

* 本质区别
  * new 是运算符，支持重载；malloc 为标准库函数，可以覆盖
* 使用区别
  * 初始化方面：
    * new 根据类型进行分配空间；malloc 只分配指定大小的内存块
    * new 在分配内存的时候会调用复杂类型的构造函数；malloc 仅仅只是分配内存
  * 返回值方面：
    * new 返回类型的指针，不需要进行指针的类型转化；malloc 返回 `void *` 指针，需要进行指针类型转化，不安全

### 3.宏定义和函数的区别

* 本质区别
  * 宏定义是进行文本替换；函数是进行函数调用

* 使用区别
  * 宏定义的的替换发生在预处理阶段；函数调用发生在编译阶段
  * 宏定义属于在结构中中快速插入代码，没有返回值；函数调用具有返回值
  * 宏定义参数没有类型，不进行类型检查；函数参数会进行类型检查
  * 宏定义不是语句，所以不需要在最后加 `;`

### 4.宏定义和 typedef 的区别

* 本质区别
  * 宏定义是进行文本替换；typedef 是类型定义
* 使用区别
  * 宏定义发生在预处理阶段，进行文本替换；typedef 是编译的一部分
  * 宏不会进行类型检查；typedef 会进行类型检查
  * 宏不是语句，不需要在结尾加 `;`；typedef 是语句，需要在结尾加 `;`
  * 宏定义没有作用域的概念；typedef 有作用域的概念

### 5.变量的声明和定义的区别

* 本质区别
  * 声明只是把变量声明的位置传递给编译器，并不分配内存空间；定义需要分配内存空间
* 使用区别
  * 相同的变量可以多处声明；定义只能定义一次

### 6.strlen 和 sizeof 的区别

* 本质区别
  * strlen 是库函数，支持覆盖；sizeof 是运算符
* 使用区别
  * strlen 传入的参数只能是字符串，而且结尾需要有 `'\0'` 来标识结尾；sizeof 可以传入任何类型的参数
  * sizeof 的结果是编译时确定的，所以不能用来获取动态分配（运行时分配）存储空间大小 

### 7.指针常量和常量指针的区别

* 本质区别
  * 指针常量，常量修饰的是指针指向的内容；常量指针，常量修饰的是指针
* 使用区别
  * 指针常量指向的对象是个常量，指向的对象不可改变；常量指针，这个指针是常量，指针的指向不可改变

### 8.a 和 &a 的区别

**如果 a 为数组，int a[10]；int (*p)[10]=&a**

* 本质区别：
  * a 为数组名，即首元素地址，+1 可以取偏移量取下一个位置的元素；&a 为 int(*p)[10] 的数组的指针，+1 是偏移这个数组的一个长度即 10 的元素的长度
  * 解引用的时候 (int *)p，输出 *p，是 int 型的大小进行读取

### 9.指针参数传递和引用参数传递的区别

* 本质区别
  * 指针参数传递本质是值传递；引用参数传递是间接寻址，存储的是主调函数比实参变量的地址，通过别名去主调函数中寻找变量
* 使用区别：
  * 指针参数相当于值传递，拷贝的副本，对这个指针进行操作（转换指向）不影响原指针的指向；引用参数传递相当于主调函数变量的一个别名，对其所有的操作都会影响主调函数中的变量。
* 编译角度的区别：
  * 指针添加到符号表中，符号表上对应的是地址值为指针变量的地址值；引用添加到符号表，符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）
  * 符号表生成后就不会在修改，所以指针的指向是可以改变的（指针变量的地址值不变，但是地址对应的指针指向可以改变），引用不可改变，变量地址已经确定

### 10.define、const、typedef、inline 的使用方法以及之间的区别

* const 和 #define 的区别
  * 本质区别：
    * const 是关键字，发生在编译链接阶段，定义常量，存储在数据段；#define 是宏定义，发生在预处理阶段，进行文本替换，定义常数，不带类型，预处理后存储在代码段
  * 使用区别：
    * const 不能重定义；#define 可以使用 #undef 进行取消定义
    * const 会进行类型检查；#define 只是简单的文本替换，不会进行类型检查
    * #define 有独特的作用：防止文件被重复引用
* typedef 和 #define 的区别
  * 本质区别：
    * typedef 是关键字，发生在编译阶段，进行类型定义；#define 是宏定义，发生在预处理阶段，进行文本替换
  * 使用区别：
    * typedef 进行类型检查；#define 不进行类型检查
    * typedef 用来定义类型别名，定义与平台无关的数据类型；#define 不仅能为类型取别名，还能定义常量、变量、编译开关等；
    * typedef 有作用域限制；#define 没有作用域限制
* inline 和 #define 的区别
  * 本质区别：
    * inline 是函数，在编译阶段进行替换；#define 是关键字，在预处理阶段进行替换
  * 使用区别：
    * inline 有类型检查；#define 没有类型检查

### 11.定义和声明的区别（变量和函数）

* 针对变量
  * 从编译原理上来说，声明只是告诉编译器，某个变量会被使用，但是编译器不会为其分配内存。定义就是分配内存
* 针对函数
  * 声明一般在头文件中，告诉编译器有函数存在
  * 定义一般在源文件中，是具体函数的实现过程，即函数体的书写

### 12.全局变量（普通函数）和 static 变量（函数）的区别

* 作用域上
  * 全部变量的作用域在整个源程序；增加了 static 的静态变量，作用域在当前文件，同时可以用来隐藏数据，是其他文件无法访问
  * 普通函数的作用域依旧是整个源程序（通过头文件的引用来使用）；static 函数的作用域在当前源文件，static 函数也叫内部函数
* 初始化和存储上
  * static 变量只初始化一次；
  * static 函数在内存中只有一份；普通函数在每个被调用中维持一份拷贝程序的局部变量存在于**堆栈**中，全局变量存在于**静态区**中，动态申请数据存在于**堆**中

### 13.静态成员与普通成员的区别

* 生命周期
  * 静态成员变量的声明周期和类存在的生命周期相同，一直存在
  * 普通成员变量的声明周期和对象的声明周期相同（随对象的创建而产生，对象的销毁而销毁）
* 共享方式
  * 静态成员变量是全类共享
  * 普通成员变量是是每个对象但是使用
* 定义位置
  * 静态成员变量存储在全局区或者数据区
  * 普通成员变量存储在堆栈中
* 初始化
  * 静态成员变量在类外初始化
  * 普通成员变量在类中初始化
* 使用上
  * 静态成员变量可以作为默认实参

### 14.strcpy 和 memcpy 的区别

* 本质区别
  * strcpy 只能复制字符串；memcpy 能复制任意内容
* 使用区别
  * strcpy 不需要指定长度，根据 '\0' 来确定结尾；memcpy 指定复制双方的其实地址，和长度（三个参数）

### 15.const char* 和 string 的区别

* 本质区别
  * const char * 字符串指针；string 是标准库中的一个，封装了对字符串的操作
* 转换
  * string.c_str() 转换成 const char *
  * const char* 和 char * 都可以直接初始化 string
  * char * 转换 const char * 直接转换
  * const char * 转换 char * 使用 memcpy

### 16.strcpy、sprintf 和 memcpy 的区别

* 本质区别
  * 操作对象的不同
    * strcpy 只能操作**字符串**
    * sprintf 操作**源对象**可以是**多种类型**，**目的操作对象**是**字符串**
    * memcpy 操作对象可以是任意
* 执行效率不同
  * memcpy 最高，strcpy、sprintf 最低
* 功能不同
  * strcpy 是拷贝字符串
  * sprintf 将其他类型数据格式化到字符串上
  * memcpy 内存块的拷贝

### 17.strcpy 和 strncpy 的区别

* 本质区别
  * strcpy 根据字符串结尾的 '\0' 来判断结束；strncpy 传入要复制长度的参数
* 拷贝参数的区别
  * strcpy 复制的字符串地址所指的空间不够大，会产生缓冲区溢出的错误；strncpy 复制源字符串的前 n 个字符，与 目的字符串所指的内存区域不能有重合，而且目的字符串必须有足够的空间放置 n 个字符
* strncpy 复制的不同情况
  * 目标长度> 指定长>源长，将源长全部拷贝到目标长，同时加上 '\0'
  * 指定长<源长，按指定长拷贝到目标字符串，不包括 '\0'
  * 指定长>目标长，运行错误

### 18.static_cast 和 c 语言中的类型转换的区别

* static_cast 更加安全
* static_cast 能够更直观的看出来强制转换的类型，可读性更高



## 特性八股

### 1.运算符重载

* 运算符重载的原因：
  * 实现类的多态

* 运算符重载的方式：
  * 成员运算符重载和非成员运算符重载，成员运算符重载时，会少一个参数，因为 this 指针绑定的左侧的对象
  * 只能重载已有的运算符，同时只能重载其内部逻辑，**不能更**改优先级和结合律，**更不能改**操作数的个数
  * 下表运算符必须是成员函数，通常以访问元素的引用作为返回值，最好同时定义下标运算符的常量版本和非常量版本
  * 箭头运算符也必须是类成员函数，解引用通常也是类的成员，同时重载的箭头运算符必须返回类指针
* 运算符种类判断（同种运算符既是一元运算符又是二元运算符）
  * 通过参数的个数进行推断

### 2.存在函数重载时，函数的匹配原则和顺序是什么

* 名字查找
* 确定候选函数
* 寻找最佳匹配

### 3.隐式转换是什么，如何消除隐式转换

* 不同类型的隐式转换
  * 基本类型的隐式转换：编译器私下进行的隐式转换
  * 类的隐式转换：在返回时，使用子类返回一个父类类型
* 隐式转换的形式
  * 基本类型的隐式转换：小 -> 大进行转换，保证**精度不丢失**
  * 类类型的隐式转换：子类 -> 父类进行转换，父类转子类，访问不到子类重新定义的变量
* 消除隐式转换的方式
  * 使用 explicit 关键字，构造函数加上 explicit，能够禁止隐式转换
  * 构造函数只接受一个参数，实际上就定义了转换为此类类型的隐式转换机制，相当于通过返回值的传递参数，构造一个返回类型的类的临时变量。通过使用 explicit（只对一个实参构造有效，多参的构造，如果除第一个形参外，其他形参都有默认参数，也可以使用）来防止隐式转换

### 4.什么时候使用指针作为参数，什么时候使用引用

* 使用引用的主要原因
  * 能修改调用函数中的数据对象
  * 通过传递引用而不是传递整个数据或对象，提高程序运行速度（值复制，对象拷贝）
* 使用引用的情况
  * 数据是类对象一般使用引用
* 使用指针的情况
  * 参数为数组的情况，只能使用指针
* 使用指针或引用的情况
  * 数据为较大的结构

### 5.函数进行参数以及返回值传递时，可以使用引用或者值传递，其中引用传递的好处是什么

* 使用的好处
  * 因为是调用函数中变量的别名，所以可以在被调用函数内部进行修改参数
  * 提高调用效率（无传值的拷贝和副本）
  * **（作为返回值）**最大好处，不在内存中产生副本，不用进行值拷贝，一直都是传入参数的别名
* 使用引用传递的**限制**
  * 不能把局部变量的引用作为返回值传递，引用引用是别名，在函数结束的时候，局部变量的值就会被销毁，引用就不存在了
  * 不能返回函数内部 new 分配的内存的引用，因为引用作为临时变量出现，没有被赋予一个实际的变量，引用所指向的空间就无法释放，造成memory leak
  * 可以返回类成员的引用，最好是 const，不能对类成员进行修改

### 6.禁止程序自动生成拷贝构造函数

* 手动重写，为了避免调用设置成 private
* 定义一个 base 基类，将 base 的构造和拷贝构造函数设置成 private，派生类就不会产生这两个函数

### 7.成员函数里使用 memset(this, 0, sizeof(*this)) 会发生什么

* 使用 memset(this, 0, sizeof(*this)) 会将对象的内存全部置为 0，更方便初始化
* 在类中存在**虚函数表**的情况下，会破坏虚函数表
* 在类中含有 **C++ 类型的对象**，在构造函数体之前已经被初始化，在使用 memset(this, 0, sizeof(*this)) 会破坏已经初始化了的对象的内存



## 标准库八股
